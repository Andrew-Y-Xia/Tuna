#!/usr/bin/env python3
"""
Convert NNUE network binary file to C++ header with embedded weights.
This allows the network to be compiled directly into the executable.
"""

import struct
import sys
import os

def read_network(filepath):
    """Read quantized network binary file and return weights."""
    with open(filepath, 'rb') as f:
        data = f.read()
    
    # Network structure (all int16_t):
    # - l0_weights: 768 * 128 = 98304 values
    # - l0_bias: 128 values
    # - l1_weights: 256 values
    # - l1_bias: 1 value
    
    INPUT_SIZE = 768
    HIDDEN_SIZE = 128
    
    offset = 0
    
    # Read Layer 0 weights
    l0_weights_count = INPUT_SIZE * HIDDEN_SIZE
    l0_weights_size = l0_weights_count * 2  # 2 bytes per int16_t
    l0_weights = struct.unpack(f'<{l0_weights_count}h', data[offset:offset + l0_weights_size])
    offset += l0_weights_size
    
    # Read Layer 0 bias
    l0_bias_count = HIDDEN_SIZE
    l0_bias_size = l0_bias_count * 2
    l0_bias = struct.unpack(f'<{l0_bias_count}h', data[offset:offset + l0_bias_size])
    offset += l0_bias_size
    
    # Read Layer 1 weights
    l1_weights_count = 2 * HIDDEN_SIZE
    l1_weights_size = l1_weights_count * 2
    l1_weights = struct.unpack(f'<{l1_weights_count}h', data[offset:offset + l1_weights_size])
    offset += l1_weights_size
    
    # Read Layer 1 bias
    l1_bias = struct.unpack('<h', data[offset:offset + 2])[0]
    
    return l0_weights, l0_bias, l1_weights, l1_bias

def format_array(name, data, values_per_line=16):
    """Format array data as C++ code."""
    lines = [f"alignas(64) const int16_t {name}[] = {{"]
    
    for i in range(0, len(data), values_per_line):
        chunk = data[i:i + values_per_line]
        line = "    " + ", ".join(f"{val}" for val in chunk)
        if i + values_per_line < len(data):
            line += ","
        lines.append(line)
    
    lines.append("};")
    return "\n".join(lines)

def generate_header(l0_weights, l0_bias, l1_weights, l1_bias, output_path):
    """Generate C++ header file with embedded network weights."""
    
    header = """//
//  NNUE_embedded.hpp
//  Tuna Chess Engine
//
//  Auto-generated embedded NNUE network weights
//  DO NOT EDIT THIS FILE MANUALLY - Generated by scripts/embed_network.py
//

#ifndef NNUE_embedded_hpp
#define NNUE_embedded_hpp

#include <cstdint>

namespace NNUE {
namespace Embedded {

// Network architecture constants
constexpr int INPUT_SIZE = 768;
constexpr int HIDDEN_SIZE = 128;

// Embedded network weights (quantized to int16_t)

"""
    
    # Add arrays
    header += "// Layer 0 weights: 768 * 128 = 98304 values\n"
    header += format_array("l0_weights", l0_weights, 16) + "\n\n"
    
    header += "// Layer 0 bias: 128 values\n"
    header += format_array("l0_bias", l0_bias, 16) + "\n\n"
    
    header += "// Layer 1 weights: 256 values\n"
    header += format_array("l1_weights", l1_weights, 16) + "\n\n"
    
    header += f"// Layer 1 bias: 1 value\n"
    header += f"alignas(64) const int16_t l1_bias = {l1_bias};\n\n"
    
    header += """} // namespace Embedded
} // namespace NNUE

#endif /* NNUE_embedded_hpp */
"""
    
    with open(output_path, 'w') as f:
        f.write(header)
    
    print(f"Generated embedded network header: {output_path}")
    print(f"  Layer 0 weights: {len(l0_weights)} values")
    print(f"  Layer 0 bias: {len(l0_bias)} values")
    print(f"  Layer 1 weights: {len(l1_weights)} values")
    print(f"  Layer 1 bias: 1 value")
    print(f"  Total size: ~{(len(l0_weights) + len(l0_bias) + len(l1_weights) + 1) * 2 / 1024:.1f} KB")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 embed_network.py <network.bin> [output.hpp]")
        print("Example: python3 embed_network.py NNUE/checkpoints/tuna-60/quantised.bin src/NNUE_embedded.hpp")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) >= 3 else "src/NNUE_embedded.hpp"
    
    if not os.path.exists(input_file):
        print(f"Error: Input file not found: {input_file}")
        sys.exit(1)
    
    print(f"Reading network from: {input_file}")
    l0_weights, l0_bias, l1_weights, l1_bias = read_network(input_file)
    
    print(f"Generating header file: {output_file}")
    generate_header(l0_weights, l0_bias, l1_weights, l1_bias, output_file)
    
    print("Done!")

if __name__ == "__main__":
    main()
